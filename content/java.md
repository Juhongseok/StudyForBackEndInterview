# Java

<br>

- [Java의 장단점](#java의-장단점)
- [데이터 타입](#데이터-타입)
- [Wrapper Class](#wrapper-class)
- [박싱 언박싱](#박싱-언박싱)
- [오토 박싱, 오토 언박싱](#오토-박싱-오토-언박싱)
- [객체지향 vs 절차지향](#객체지향-vs-절차지향)
- [OOP(객체지향 프로그래밍 Object Oriented Programming)](#oop객체지향-프로그래밍-object-oriented-programming)
- [OOP의 5가지 원칙 SOLID](#oop의-5가지-원칙-solid)
- [Java Collection Framework](#java-collection-framework)
- [람다](#람다)
--------
### Java의 장단점
- 장점
    - 운영체제에 독립적
        - 운영체제가 아닌 JVM위에서 동작하기 때문이다
    
    - 객체지향의 언어
        - 캡슐화, 상속, 추상화, 다형성등 여러 언어적 지원하여 객체지향 프로그래밍 가능하다

    - 동적 로딩 지원
        - 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 **필요한 시점에** 클래스를 동적 로딩해서 생성된다
        유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다

- 단점
    - 비교적 느림
        - 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 조금 느리다

## 데이터 타입
- 기본 타입(Primitive Type)
    - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다
    - 정수형 : byte, short, int long
    - 실수형 : float, double
    - 논리형 : boolean
    - 문자형 : char

- 참조 타입(Reference Type)
    - 기본형을 제외한 나머지 모두가 참조형이다
    - new 키워드를 이용해 객체를 생성하고 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap영역에 저장된다
    - 생성된 객체의 주소를 참조한다
    - String, Integer, List, Class등이 있다

### Wrapper Class
만일 메서드의 매개변수로 객체 타입이 요구된다면 기본 타입의 데이터를 사용할 수 없다

이때 기본 타입의 데이터를 객체로 변환 후 전달을 해야한다

|기본 타입|래퍼 클래스|
|:--:|:--:|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|
|boolean|Boolean|

### 박싱, 언박싱
래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있다.

<br>
기본타입의 데이터 -> 래퍼 클래스의 인스턴스 : 박싱
래퍼 클래스의 인스턴스에 저장된 값 -> 기본타입의 데이터 : 언박싱

### 오토 박싱, 오토 언박싱
JDK1.5 이후부터는 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 자동으로 이를 처리해주고 이를 오토박싱, 오토 언박싱이라 부른다

```java
Integer number = new Integer(10); // 박싱
int n = number.intValue(); // 언박싱
//--------------------------------//
Integer number = 1; // 오토 박싱
int n = number; // 오토 언박싱
```

래퍼 클래스를 비교할때 주의점으로는 동등비교(==)시에는 ==연산자가 아닌 `equals()`메서드를 사용해야 한다

클래스이기 때문에 내부 값이 아닌 주소값을 비교하여 잘못된 결과값을 나타낼 수 있다

### 객체지향 vs 절차지향
- 절차 지향 프로그래밍
    - 실행하고자 하는 절차를 정하고, 순차적으로 프로그래밍 하는 방식으로 빠르다.
    - 엄격하게 순서가 정해져 있기에 비효율적이고 유지보수가 어렵다.
    - 목적을 달성하기 위한 일의 흐름에 중점을 둔다.
-객체 지향 프로그래밍
    - 구현해야할 객체들 사이의 상호작용을 프로그래밍하는 방식으로 상속, 다형성, 추상화, 캡슐화를 통해 결합도를 낮추고 응집도를 높일 수 있으며 코드의 재사용성도 높일 수 있다.

### OOP(객체지향 프로그래밍 Object Oriented Programming)
- 추상화
    - 정보은닉, 높은 응집도, 낮은 결합도
- 캡슐화
    - 공통적인 특징을 파악하여 하나의 개념으로 다루는 것
    - 목적과 관련이 없는부분 제거
- 상속
    - 기존 상위 클래스를 근거하여 새로운 클래스와 행위 정의
- 다형성
    - 형태는 같은데 다른 행위를 하도록 하는 것

### OOP의 5가지 원칙 SOLID
- S (SRP) 단일 책임 원칙
    - 하나의 클래스는 하나의 책임만 가져야한다
- O (OCP) 개방 폐쇄 원칙
    - 확장에는 열려있으나 변경에는 닫혀있어야 한다
    - 인터페이스를 구현한 새로운 클래스 구현
    - 역할과 구현 분리
- L (LIP) 리코스프 치환 원칙
    - 객체는 프로그램의 정확성을 깨뜨리지 않으며 하위 타입으로 바꿀수 있어야 한다
    - 인터페이스를 구현한 구현체를 믿고 사용하기 위해 필요
- I (ISP) 인터페이스 분리 원칙
    - 여러 인터페이스가 범용 인터페이스 하나보다 낫다
    - 인터페이스가 명확, 대체 가능성이 높아진다
- D (DIP) 의존관계 역전 원칙
    - 구현클래스(구체화)에 의존하지 않고 인터페이스(추상화)에 의존해야한다

### Java Collection Framework
![collection](/image/java-collections-framework.png)

- Map
    - 검색할 수 있는 인터페이스
    - 데이터를 삽입할 때 Key와 Value의 형태로 삽입되며, Key를 이용해서 Value를 얻을 수 있다.
- Collection
    - List
        - 순서가 있는 Collection
        - 데이터를 중복해서 포함할 수 있다.
    - Set
        - 집합적인 개념의 Collection
        - 순서의 의미가 없다.
        - 데이터를 중복해서 포함할 수 없다.

### 람다
- 자바 8에서 등장
- 메서드를 하나의 식으로 표현하는 익명 함수
- 인터페이스 내에 한 개의 추상 메서드만 정의되어있는 함수형(Function) 인터페이스에 사용 가능
    - 장점
        -기존에 익명함수로 작성하던 코드를 줄일 수 있음
    - 가독성 증가
    - 병렬 프로그래밍이 용이하다.

[추가 설명](https://whatistudy.tistory.com/entry/%EB%9E%8C%EB%8B%A4)
